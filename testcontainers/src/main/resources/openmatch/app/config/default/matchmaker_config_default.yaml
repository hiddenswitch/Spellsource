logging:
  level: debug
  format: text
  rpc: true
# Open Match applies the exponential backoff strategy for its retryable gRPC calls.
# The settings below are the default backoff configuration used in Open Match.
# See https://github.com/cenkalti/backoff/blob/v3/exponential.go for detailed explanations
backoff:
  # The initial retry interval (in milliseconds)
  initialInterval: 100ms
  # maxInterval caps the maximum time elapsed for a retry interval
  maxInterval: 500ms
  # The next retry interval is multiplied by this multiplier
  multiplier: 1.5
  # Randomize the retry interval
  randFactor: 0.5
  # maxElapsedTime caps the retry time (in milliseconds)
  maxElapsedTime: 3000ms
api:
  minimatch:
    grpcport: 50509
    httpport: 51509
  backend:
#    hostname:
    grpcport: 50505
    httpport: 51505
  frontend:
#    hostname: "{{ include "openmatch.frontend.hostName" . }}"
    grpcport: 50504
    httpport: 51504
  query:
#    hostname: "{{ include "openmatch.query.hostName" . }}"
    grpcport: 50503
    httpport: 51503
  synchronizer:
    enabled: true
    registrationIntervalMs: 3000ms
    proposalCollectionIntervalMs: 2000ms
#    hostname: "{{ include "openmatch.synchronizer.hostName" . }}"
    grpcport: 50506
    httpport: 51506
#  swaggerui:
#    hostname: "{{ include "openmatch.swaggerui.hostName" . }}"
#    httpport: "{{ .Values.swaggerui.httpPort }}"
  # Configurations for api.test and api.scale are used for testing.
#  test:
#    hostname: "{{ include "openmatch.fullname" . }}-test"
#    grpcport: "50509"
#    httpport: "51509"
#  scale:
#    httpport: "51509"
redis:
  # BYO Redis setups
  hostname: localhost # {{ index .Values "open-match-core" "redis" "hostname" }}
  port: 6379 # {{ index .Values "open-match-core" "redis" "port" }}
  user: "admin" # {{ index .Values "open-match-core" "redis" "user" }}
  usePassword: false # {{ .Values.redis.usePassword }}
  assignedDeleteTimeout: 100ms
#  passwordPath: {{ .Values.redis.secretMountPath }}/redis-password
  pool:
    maxIdle: 200
    maxActive: 0
    idleTimeout: 0
    healthCheckTimeout: 300ms
telemetry:
  reportingPeriod: "1m" # "{{ .Values.global.telemetry.reportingPeriod }}"
  traceSamplingFraction: 0.01 # "{{ .Values.global.telemetry.traceSamplingFraction }}"
  zpages:
    enable: false # "{{ .Values.global.telemetry.zpages.enabled }}"
  jaeger:
    enable: false # "{{ .Values.global.telemetry.jaeger.enabled }}"
#    agentEndpoint: "{{ tpl .Values.global.telemetry.jaeger.agentEndpoint . }}"
#    collectorEndpoint: "{{ tpl .Values.global.telemetry.jaeger.collectorEndpoint . }}"
  prometheus:
    enable: false # "{{ .Values.global.telemetry.prometheus.enabled }}"
#    endpoint: "{{ .Values.global.telemetry.prometheus.endpoint }}"
#    serviceDiscovery: "{{ .Values.global.telemetry.prometheus.serviceDiscovery }}"
  stackdriverMetrics:
    enable: false # "{{ .Values.global.telemetry.stackdriverMetrics.enabled }}"
#    gcpProjectId: "{{ .Values.global.gcpProjectId }}"
#    prefix: "{{ .Values.global.telemetry.stackdriverMetrics.prefix }}"