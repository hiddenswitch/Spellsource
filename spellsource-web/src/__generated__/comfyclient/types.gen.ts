// This file is auto-generated by @hey-api/openapi-ts

export type ExecutionStatusAsDict = {
  status_str: "success" | "error";
  completed: boolean;
  messages: Array<string>;
};

export type status_str = "success" | "error";

export type ExtraData = {
  extra_pnginfo?: {
    workflow?: Workflow;
  };
};

export type FileOutput = {
  filename: string;
  subfolder: string;
  type: string;
  abs_path: string;
};

export type InputSpec = [
  string | Array<string | number | boolean>,
  {
    default?: string;
    min?: number;
    max?: number;
    step?: number;
    multiline?: boolean;
  }
];

export type Node = {
  input?: {
    required: {
      [key: string]: InputSpec;
    };
    optional?: {
      [key: string]: InputSpec;
    };
    hidden?: {
      [key: string]: InputSpec;
    };
  };
  output?: Array<string>;
  /**
   * Indicates if the output of the corresponding index as the item in this array is a list output.
   */
  output_is_list?: Array<boolean>;
  output_name?: Array<string>;
  name?: string;
  display_name?: string;
  description?: string;
  category?: string;
  output_node?: boolean;
};

export type Output = {
  [key: string]: FileOutput;
};

/**
 * The keys are node IDs, the values are output objects.
 *
 */
export type Outputs = {
  [key: string]: Output;
};

/**
 * The keys are stringified integers corresponding to nodes.
 *
 * You can retrieve the last prompt run using GET /api/v1/prompts
 *
 */
export type Prompt = {
  [key: string]: PromptNode;
};

export type PromptNode = {
  _meta?: {
    /**
     * The title of the node when authored in the workflow. Set only when the end user changed it using the
     * panel properties in the UI.
     *
     */
    title?: string;
  };
  /**
   * The node's class type, which maps to a class in NODE_CLASS_MAPPINGS.
   */
  class_type: string;
  /**
   * The inputs for the node, which can be scalar values or references to other nodes' outputs.
   */
  inputs: {
    [key: string]: number | string | boolean | [string, number];
  };
  is_changed?: Array<string> | string;
};

export type PromptRequest = {
  client_id?: string;
  prompt: Prompt;
  extra_data?: ExtraData;
};

/**
 * An item that was added to the queue.
 *
 */
export type QueueTuple = [number, string, Prompt, ExtraData, Array<string>];

export type ValidationErrorDict = {
  type: string;
  message: string;
  details: string;
  extra_info: {
    exception_type: string;
    traceback: Array<string>;
  };
};

export type Workflow = {
  last_node_id?: number;
  last_link_id?: number;
  nodes?: Array<{
    id?: number;
    type?: string;
    pos?: [number, number];
    size?: {
      "0"?: number;
      "1"?: number;
    };
    flags?: {
      [key: string]: {
        [key: string]: unknown;
      };
    };
    order?: number;
    mode?: number;
    inputs?: Array<{
      name?: string;
      type?: string;
      link?: number;
    }>;
    outputs?: Array<{
      name?: string;
      type?: string;
      links?: Array<number>;
      slot_index?: number;
    }>;
    properties?: {
      [key: string]: unknown;
    };
    widgets_values?: Array<string>;
  }>;
  links?: Array<Array<number | string>>;
  groups?: Array<{
    [key: string]: unknown;
  }>;
  config?: {
    [key: string]: unknown;
  };
  extra?: {
    [key: string]: unknown;
  };
  version?: number;
};

export type GetRootUiResponse = string;

export type GetRootUiError = unknown;

export type GetEmbeddingsUiResponse = Array<string>;

export type GetEmbeddingsUiError = unknown;

export type GetExtensionsUiResponse = Array<string>;

export type GetExtensionsUiError = unknown;

export type UploadImageUiData = {
  body?: {
    /**
     * The image binary data
     */
    image?: Blob | File;
  };
};

export type UploadImageUiResponse = {
  /**
   * The name to use in a workflow.
   *
   */
  name?: string;
};

export type UploadImageUiError = unknown;

export type ViewImageUiData = {
  query: {
    channel?: "rgba" | "rgb" | "a";
    filename: string;
    preview?: string;
    subfolder?: string;
    type?: "output" | "input" | "temp";
  };
};

export type ViewImageUiResponse = Blob | File;

export type ViewImageUiError = unknown;

export type GetPromptUiResponse = {
  exec_info?: {
    queue_remaining?: number;
  };
};

export type GetPromptUiError = unknown;

export type PostPromptUiData = {
  body?: PromptRequest;
};

export type PostPromptUiResponse = {
  /**
   * The ID of the prompt that was queued
   */
  prompt_id?: string;
};

export type PostPromptUiError = string;

export type GetObjectInfoUiResponse = {
  [key: string]: Node;
};

export type GetObjectInfoUiError = unknown;

export type GetHistoryUiResponse = {
  [key: string]: {
    prompt?: QueueTuple;
    outputs?: Outputs;
    status?: {
      status_str?: string;
      completed?: boolean;
      messages?: Array<string>;
    };
  };
};

export type GetHistoryUiError = unknown;

export type PostHistoryUiData = {
  body?: {
    clear?: boolean;
    delete?: Array<number>;
  };
};

export type PostHistoryUiResponse = unknown;

export type PostHistoryUiError = unknown;

export type GetQueueUiResponse = {
  queue_running?: Array<QueueTuple>;
  queue_pending?: Array<QueueTuple>;
};

export type GetQueueUiError = unknown;

export type PostQueueUiData = {
  body?: {
    clear?: boolean;
    delete?: Array<number>;
  };
};

export type PostQueueUiResponse = unknown;

export type PostQueueUiError = unknown;

export type PostInterruptUiResponse = unknown;

export type PostInterruptUiError = unknown;

export type FreeUiData = {
  body?:
    | {
        unload_models: boolean;
      }
    | {
        free_memory: boolean;
      };
};

export type FreeUiResponse = unknown;

export type FreeUiError = unknown;

export type GetPromptData = {
  path: {
    /**
     * The ID of the prompt to query.
     *
     */
    prompt_id: string;
  };
};

export type ListPromptsResponse = Prompt;

export type ListPromptsError = unknown;

export type GenerateData = {
  body?: Prompt;
  headers?: {
    /**
     * Specifies the media type the client is willing to receive.
     *
     * If +respond-async is specified after your Accept mimetype, the request will be run async and you will get 202 when the prompt was queued.
     *
     */
    Accept?: "application/json" | "image/png" | "application/json+respond-async";
    /**
     * When respond-async is in your Prefer header, the request will be run async and you will get 202 when the prompt was queued.
     *
     */
    Prefer?: "respond-async" | "";
  };
};

export type GenerateResponse =
  | {
      /**
       * A deprecated list of URLs to binary outputs, whenever save nodes are used.
       *
       * For each SaveImage node, there will be two URLs: the internal URL returned by the worker, and
       * the URL for the image based on the `--external-address` / `COMFYUI_EXTERNAL_ADDRESS` configuration.
       *
       * @deprecated
       */
      urls: Array<string>;
      outputs: Outputs;
    }
  | {
      /**
       * The ID of the prompt that was queued
       */
      prompt_id?: string;
    }
  | void;

export type GenerateError = ValidationErrorDict | unknown | ExecutionStatusAsDict;
