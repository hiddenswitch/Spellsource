import groovy.json.JsonSlurper
import org.apache.tools.ant.taskdefs.condition.Os

plugins {
  id "com.github.node-gradle.node"
  id "base"
  id "java"
  id "next"
  id "docker"
}

apply from: '../gradle/instrument.gradle'
apply from: '../gradle/node.gradle'

def isWindows = org.gradle.internal.os.OperatingSystem.current().isWindows()
def isLinux = org.gradle.internal.os.OperatingSystem.current().isLinux()
def isMacOs = org.gradle.internal.os.OperatingSystem.current().isMacOsX()
def spellsourceDepTask = ':spellsource-web-cardeditor-support:shadowJar'
def yarnVersionStr = (new JsonSlurper().parse(file("package.json")).packageManager as String).split("@")[1]
def yarnPath = "languages/nodejs/bin/yarn"
def npmPath = "bin/npm"
def nodePath = "bin/node"
// todo: this will have to be a distinct path
// you can't really operate them side by side
def graalNpmPrefix = 'node_modules'
def packageJsonFile = file('package.json')
def packageJson = new JsonSlurper().parseText(packageJsonFile.text)
def scripts = packageJson.scripts
def scriptNames = ["dev": "run"]
def binExt = isWindows ? ".cmd" : ""
def distDir = "docker/spellsource/web"


evaluationDependsOn(":spellsource-server")
evaluationDependsOn(":spellsource-python")

scripts.each { scriptName, command ->
  def name = "yarnRun${scriptName.capitalize()}"
  def setGroup = 'yarn'
  if (scriptNames.containsKey(scriptName)) {
    name = scriptNames[scriptName]
    setGroup = 'spellsource'
  }
  tasks.register(name, YarnTask) {
    group(setGroup)
    dependsOn 'yarn'
    args = ['run', scriptName]
  }
}

tasks.named('yarnRunTest') {
  dependsOn "yarnRunPlaywrightInstall"
}

tasks.named('test') {
  dependsOn 'yarnRunTest', spellsourceDepTask
}


tasks.register('copyComfyClient') {
  dependsOn(':spellsource-python:generateTypeScriptClient')
  def addlInput = project(':spellsource-python').layout.buildDirectory.dir("comfyclient")
  def addlOutput = "src/__generated__/comfyclient"
  inputs.dir(addlInput)
  outputs.dir("src/__generated__/comfyclient")
  outputs.cacheIf { true }
  doLast {
    copy {
      from addlInput
      into addlOutput
      include("**/*.ts")
      exclude("index.ts")
    }
  }

  finalizedBy 'fixComfyClient'
}

tasks.register('fixComfyClient') {
  doLast {
    def http = file("src/__generated__/comfyclient/http/http.ts")

    http.text = http.text
            .replaceFirst(/export \* from/, 'export {} from')
            .replaceFirst(/(reader.readAsText\(data)\)/, '$1 as any)')
            .replaceFirst(/(return new File\(\[data], fileName, \{ type: contentType }\));/, '$1 as any;')

    def defaultApi = file("src/__generated__/comfyclient/apis/DefaultApi.ts")

    defaultApi.text = defaultApi.text.replaceFirst(/(localVarFormParams.append\('image', image),/, '$1 as any,')

  }
}

tasks.named("yarnSetup").configure {
  enabled = false
  dependsOn "corepack"
}

tasks.named('yarn').configure {
  group('spellsource')
  // todo: we need to patch the generator
  //  dependsOn += ['copyComfyClient']
  args = ['--immutable']
}

tasks.register("corepack") {
  enabled = true
  def dirPath = ".gradle/yarn/yarn-v${yarnVersionStr}/${isWindows ? "" : "/bin"}"
  outputs.dir(dirPath)
  doLast {
    mkdir(dirPath)
    exec {
      commandLine "${isMacOs ? '/opt/homebrew/bin/' : ''}corepack${binExt}", "enable", "--install-directory", file(dirPath).absolutePath
    }
  }
}

tasks.named('yarnSetup').configure {
  dependsOn "corepack"
  enabled = false
}


Provider<JavaLauncher> thisToolchain() {
  return (project.services.get(JavaToolchainService) as JavaToolchainService).launcherFor(java.toolchain)
}

Provider<RegularFile> graalFileFor(String graalBinary) {
  def toolchain = thisToolchain()
  return toolchain.map { it.metadata.installationPath.file("${graalBinary}${Os.isFamily(Os.FAMILY_WINDOWS) ? '.cmd' : ''}") }
}

tasks.register('nodeJsDepsGraal') {
  def bins = ["bin/node", "bin/yarn"]
  onlyIf {
    bins.every { bin -> graalFileFor(bin).map { !it.asFile.exists() }.get() }
  }

  inputs.property("bins", bins)
  outputs.file(graalFileFor("bin/yarn"))
  outputs.cacheIf { false }

  doLast {
    exec {
      executable graalFileFor(isLinux ? "lib/installer/bin/gu" : "bin/gu").map { it.asFile.path }.get()
      args 'install', 'org.graalvm.nodejs'
    }

    exec {
      executable graalFileFor(npmPath).map { it.asFile.path }.get()
      args "install", "-g", "yarn"
    }
  }
}

clean {
  delete '.cache'
  delete 'node_modules'
}

tasks.register('copyGameJavadoc', Copy) {
  description("Copies the game module's javadoc into the public directory of the website")
  dependsOn ':spellsource-game:javadoc'
  from tasks.getByPath(':spellsource-game:javadoc').outputs
  into './public/javadoc'
}

tasks.register('copyNetJavadoc', Copy) {
  description("Copies the net module's javadoc into the public directory of the website")
  dependsOn ':spellsource-server:javadoc'
  from tasks.getByPath(':spellsource-server:javadoc').outputs
  into './public/netjavadoc'
}


tasks.named("createDist").configure {
  outputs.dir(distDir)

  group "spellsource"

  doLast {
    copy {
      from "$project.parent.projectDir/CONTRIBUTE.md"
      into "$distDir/"
    }
  }
}

def projectVersion = System.getenv("PROJECT_VERSION") ?: project.version.toString()
def spellsourceTags = ['latest', projectVersion]
def spellsourceImage = "ghcr.io/hiddenswitch/${distDir.replace("docker/", "")}"

tasks.register('githubDockerPush') {
  dependsOn tasks.named("createImage_spellsource_web_linux_amd64")

  group "spellsource"

  doLast {
    for (def image : spellsourceTags.collect { tag -> "$spellsourceImage:$tag" }) {
      exec {
        commandLine(['docker', 'push'] + [image])
      }
    }
  }
}

def venvDir = "$rootDir/.venv"
def sitePackagesDir = isWindows ?
        "${venvDir}/Lib/site-packages" :
        // todo: get the path for real using
        // python -c "import site; print(site.getsitepackages()[0])"
        "${venvDir}/lib/python3.11/site-packages"


tasks.named("yarnRunOpenapi-ts").configure {
  group('spellsource')
  def inputSpecFile = provider { file("$sitePackagesDir/comfy/api/openapi.yaml") }
// don't even configure if it doesn't exist
  onlyIf { inputSpecFile.map { it.exists() } }
  def inputSpec = inputSpecFile.map { it.exists() ? it.path : project(":spellsource-python").file("dummy.yaml").path }

  outputs.cacheIf { true }

  inputs.file(inputSpec)
  outputs.dir("src/__generated__/comfyclient")
  args = ["run", "openapi-ts", "-i", inputSpec.get(), "-o", "src/__generated__/comfyclient", "-c", "@hey-api/client-fetch"]
}