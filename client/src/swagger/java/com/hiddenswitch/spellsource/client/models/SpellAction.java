/*
 * Hidden Switch Spellsource API
 * The Spellsource API for matchmaking, user accounts, collections management and more.  To get started, create a user account and make sure to include the entirety of the returned login token as the X-Auth-Token header. You can reuse this token, or login for a new one.  ClientToServerMessage and ServerToClientMessage are used for the realtime game state and actions two-way websocket interface for actually playing a game. Envelope is used for the realtime API services.  For the routes that correspond to the paths in this file, visit the Gateway.java file in the Spellsource-Server GitHub repository located in this definition file. 
 *
 * OpenAPI spec version: 4.0.1
 * Contact: ben@hiddenswitch.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.hiddenswitch.spellsource.client.models;

import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import com.hiddenswitch.spellsource.client.models.ActionType;
import com.hiddenswitch.spellsource.client.models.Entity;
import com.hiddenswitch.spellsource.client.models.SpellAction;
import com.hiddenswitch.spellsource.client.models.TargetActionPair;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import java.io.Serializable;
import com.fasterxml.jackson.annotation.JsonInclude;

/**
 * A spell action describes a possible action the player can take. The list of SpellAction objects in the ServerToClientMessage is exhaustive and represents every possible action. 
 */
@ApiModel(description = "A spell action describes a possible action the player can take. The list of SpellAction objects in the ServerToClientMessage is exhaustive and represents every possible action. ")
@JsonInclude(JsonInclude.Include.NON_DEFAULT)

public class SpellAction implements Serializable {

  @JsonProperty("sourceId")
  private Integer sourceId = -1;

  @JsonProperty("actionType")
  private ActionType actionType = null;

  @JsonProperty("description")
  private String description = null;

  @JsonProperty("entity")
  private Entity entity = null;

  @JsonProperty("choices")
  private List<SpellAction> choices = null;

  @JsonProperty("action")
  private Integer action = -1;

  @JsonProperty("targetKeyToActions")
  private List<TargetActionPair> targetKeyToActions = null;

  public SpellAction sourceId(Integer sourceId) {
    this.sourceId = sourceId;
    return this;
  }

   /**
   * The ID of the entity (minion or card) that is the source of the action. The client is guaranteed to have this entity in its entities array. For a SpellAction whose actionType is DISCOVER, the source is the entity in the acting player&#39;s discover zone. In the engine, the source is the entity that is prompting the discover (e.g. a minion if an opener is causing the discover, or the spell card being played). Sometimes ENDTURN will not be available, this is because some actions like DISCOVER and BATTLECRY cannot be interrupted. Running out of time will result in ENDTURN being chosen or a random DISCOVER or BATTLECRY action. This will occur on the server, not the client. 
   * @return sourceId
  **/
  @ApiModelProperty(value = "The ID of the entity (minion or card) that is the source of the action. The client is guaranteed to have this entity in its entities array. For a SpellAction whose actionType is DISCOVER, the source is the entity in the acting player's discover zone. In the engine, the source is the entity that is prompting the discover (e.g. a minion if an opener is causing the discover, or the spell card being played). Sometimes ENDTURN will not be available, this is because some actions like DISCOVER and BATTLECRY cannot be interrupted. Running out of time will result in ENDTURN being chosen or a random DISCOVER or BATTLECRY action. This will occur on the server, not the client. ")
  public Integer getSourceId() {
    return sourceId;
  }

  public void setSourceId(Integer sourceId) {
    this.sourceId = sourceId;
  }

  public SpellAction actionType(ActionType actionType) {
    this.actionType = actionType;
    return this;
  }

   /**
   * Get actionType
   * @return actionType
  **/
  @ApiModelProperty(value = "")
  public ActionType getActionType() {
    return actionType;
  }

  public void setActionType(ActionType actionType) {
    this.actionType = actionType;
  }

  public SpellAction description(String description) {
    this.description = description;
    return this;
  }

   /**
   * A user-readable description of this action. This is typically not rendered in the client except in logs. 
   * @return description
  **/
  @ApiModelProperty(value = "A user-readable description of this action. This is typically not rendered in the client except in logs. ")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public SpellAction entity(Entity entity) {
    this.entity = entity;
    return this;
  }

   /**
   * Get entity
   * @return entity
  **/
  @ApiModelProperty(value = "")
  public Entity getEntity() {
    return entity;
  }

  public void setEntity(Entity entity) {
    this.entity = entity;
  }

  public SpellAction choices(List<SpellAction> choices) {
    this.choices = choices;
    return this;
  }

  public SpellAction addChoicesItem(SpellAction choicesItem) {
    if (this.choices == null) {
      this.choices = new ArrayList<>();
    }
    this.choices.add(choicesItem);
    return this;
  }

   /**
   * When set, represents a choose one action with entities set to render. Those entities&#39; id property corresponds to the choices&#39;s sourceId property. The parent/root action&#39;s sourceId corresponds to the actual entity that reveals the choices. 
   * @return choices
  **/
  @ApiModelProperty(value = "When set, represents a choose one action with entities set to render. Those entities' id property corresponds to the choices's sourceId property. The parent/root action's sourceId corresponds to the actual entity that reveals the choices. ")
  public List<SpellAction> getChoices() {
    return choices;
  }

  public void setChoices(List<SpellAction> choices) {
    this.choices = choices;
  }

  public SpellAction action(Integer action) {
    this.action = action;
    return this;
  }

   /**
   * The action index corresponding to this action.  If targetKeyToActions is length zero or null, the action is valid and set, corresponding to an action that does not take a user-specified target. This includes all DISCOVER actions, ENDTURN, but *never* a summon, even if no minions are on the board. 
   * @return action
  **/
  @ApiModelProperty(value = "The action index corresponding to this action.  If targetKeyToActions is length zero or null, the action is valid and set, corresponding to an action that does not take a user-specified target. This includes all DISCOVER actions, ENDTURN, but *never* a summon, even if no minions are on the board. ")
  public Integer getAction() {
    return action;
  }

  public void setAction(Integer action) {
    this.action = action;
  }

  public SpellAction targetKeyToActions(List<TargetActionPair> targetKeyToActions) {
    this.targetKeyToActions = targetKeyToActions;
    return this;
  }

  public SpellAction addTargetKeyToActionsItem(TargetActionPair targetKeyToActionsItem) {
    if (this.targetKeyToActions == null) {
      this.targetKeyToActions = new ArrayList<>();
    }
    this.targetKeyToActions.add(targetKeyToActionsItem);
    return this;
  }

   /**
   * An array of entity ID-action pairs that let you convert a valid target to an action index to respond with. Defined if this spell is targetable.  This is null or length zero if the target does not have targeted actions. Use the action property instead for that situation.  A SpellAction with actionType SUMMON will have a targetKeyToActions entry with a target of -1 corresponding to the *last* (rightmost) minion position to summon, while all other targets correspond to minions on the board. 
   * @return targetKeyToActions
  **/
  @ApiModelProperty(value = "An array of entity ID-action pairs that let you convert a valid target to an action index to respond with. Defined if this spell is targetable.  This is null or length zero if the target does not have targeted actions. Use the action property instead for that situation.  A SpellAction with actionType SUMMON will have a targetKeyToActions entry with a target of -1 corresponding to the *last* (rightmost) minion position to summon, while all other targets correspond to minions on the board. ")
  public List<TargetActionPair> getTargetKeyToActions() {
    return targetKeyToActions;
  }

  public void setTargetKeyToActions(List<TargetActionPair> targetKeyToActions) {
    this.targetKeyToActions = targetKeyToActions;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SpellAction spellAction = (SpellAction) o;
    return Objects.equals(this.sourceId, spellAction.sourceId) &&
        Objects.equals(this.actionType, spellAction.actionType) &&
        Objects.equals(this.description, spellAction.description) &&
        Objects.equals(this.entity, spellAction.entity) &&
        Objects.equals(this.choices, spellAction.choices) &&
        Objects.equals(this.action, spellAction.action) &&
        Objects.equals(this.targetKeyToActions, spellAction.targetKeyToActions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(sourceId, actionType, description, entity, choices, action, targetKeyToActions);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SpellAction {\n");
    
    sb.append("    sourceId: ").append(toIndentedString(sourceId)).append("\n");
    sb.append("    actionType: ").append(toIndentedString(actionType)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    entity: ").append(toIndentedString(entity)).append("\n");
    sb.append("    choices: ").append(toIndentedString(choices)).append("\n");
    sb.append("    action: ").append(toIndentedString(action)).append("\n");
    sb.append("    targetKeyToActions: ").append(toIndentedString(targetKeyToActions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

