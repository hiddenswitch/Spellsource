/*
 * Hidden Switch Spellsource API
 * The Spellsource API for matchmaking, user accounts, collections management and more.  To get started, create a user account and make sure to include the entirety of the returned login token as the X-Auth-Token header. You can reuse this token, or login for a new one.  ClientToServerMessage and ServerToClientMessage are used for the realtime game state and actions two-way websocket interface for actually playing a game. Envelope is used for the realtime API services.  For the routes that correspond to the paths in this file, visit the Gateway.java file in the Spellsource-Server GitHub repository located in this definition file. 
 *
 * OpenAPI spec version: 4.0.1
 * Contact: ben@hiddenswitch.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.hiddenswitch.spellsource.client.models;

import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.Serializable;
import com.fasterxml.jackson.annotation.JsonInclude;

/**
 * Specifies a sprite or image 
 */
@ApiModel(description = "Specifies a sprite or image ")
@JsonInclude(JsonInclude.Include.NON_DEFAULT)

public class Sprite implements Serializable {

  @JsonProperty("named")
  private String named = null;

  /**
   * The sprite&#39;s pivor point.   - BOTTOM: The center bottom of the sprite (i.e. 0.5, 1.0)  - DIMETRIC_2X1_FLOOR: Calculates the pivot point by ascending one pixel from the bottom for every four pixels    of width, as though the pivot point is the middle of the rectangle formed at the bottom of the sprite.  - CENTER: The center middle of the sprite (i.e. 0.5, 0.5)  - FLYING: Beyond the bottom of the sprite (i.e. 0.5, 2.0) 
   */
  public enum PivotEnum {
    BOTTOM("BOTTOM"),
    
    DIMETRIC_2X1_FLOOR("DIMETRIC_2X1_FLOOR"),
    
    CENTER("CENTER"),
    
    FLYING("FLYING");

    private String value;

    PivotEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static PivotEnum fromValue(String text) {
      for (PivotEnum b : PivotEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
  }

  @JsonProperty("pivot")
  private PivotEnum pivot = null;

  public Sprite named(String named) {
    this.named = named;
    return this;
  }

   /**
   * The sprite name in the client. 
   * @return named
  **/
  @ApiModelProperty(value = "The sprite name in the client. ")
  public String getNamed() {
    return named;
  }

  public void setNamed(String named) {
    this.named = named;
  }

  public Sprite pivot(PivotEnum pivot) {
    this.pivot = pivot;
    return this;
  }

   /**
   * The sprite&#39;s pivor point.   - BOTTOM: The center bottom of the sprite (i.e. 0.5, 1.0)  - DIMETRIC_2X1_FLOOR: Calculates the pivot point by ascending one pixel from the bottom for every four pixels    of width, as though the pivot point is the middle of the rectangle formed at the bottom of the sprite.  - CENTER: The center middle of the sprite (i.e. 0.5, 0.5)  - FLYING: Beyond the bottom of the sprite (i.e. 0.5, 2.0) 
   * @return pivot
  **/
  @ApiModelProperty(value = "The sprite's pivor point.   - BOTTOM: The center bottom of the sprite (i.e. 0.5, 1.0)  - DIMETRIC_2X1_FLOOR: Calculates the pivot point by ascending one pixel from the bottom for every four pixels    of width, as though the pivot point is the middle of the rectangle formed at the bottom of the sprite.  - CENTER: The center middle of the sprite (i.e. 0.5, 0.5)  - FLYING: Beyond the bottom of the sprite (i.e. 0.5, 2.0) ")
  public PivotEnum getPivot() {
    return pivot;
  }

  public void setPivot(PivotEnum pivot) {
    this.pivot = pivot;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Sprite sprite = (Sprite) o;
    return Objects.equals(this.named, sprite.named) &&
        Objects.equals(this.pivot, sprite.pivot);
  }

  @Override
  public int hashCode() {
    return Objects.hash(named, pivot);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Sprite {\n");
    
    sb.append("    named: ").append(toIndentedString(named)).append("\n");
    sb.append("    pivot: ").append(toIndentedString(pivot)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

