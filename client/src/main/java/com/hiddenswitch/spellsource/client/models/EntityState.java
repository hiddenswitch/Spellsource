/*
 * Hidden Switch Spellsource API
 * The Spellsource API for matchmaking, user accounts, collections management and more.  To get started, create a user account and make sure to include the entirety of the returned login token as the X-Auth-Token header. You can reuse this token, or login for a new one.  ClientToServerMessage and ServerToClientMessage are used for the realtime game state and actions two-way websocket interface for actually playing a game. Envelope is used for the realtime API services.  For the routes that correspond to the paths in this file, visit the Gateway.java file in the Spellsource-Server GitHub repository located in this definition file. 
 *
 * OpenAPI spec version: 3.0.5
 * Contact: ben@hiddenswitch.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.hiddenswitch.spellsource.client.models;

import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import com.hiddenswitch.spellsource.client.models.EntityLocation;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import java.io.Serializable;
import com.fasterxml.jackson.annotation.JsonInclude;

/**
 * The entity state contains all the mutable values of an entity. In the future, the server will provide a list of exact changes to this state. 
 */
@ApiModel(description = "The entity state contains all the mutable values of an entity. In the future, the server will provide a list of exact changes to this state. ")
@JsonInclude(JsonInclude.Include.NON_DEFAULT)

public class EntityState implements Serializable {
  private static final long serialVersionUID = 1L;

  @JsonProperty("location")
  private EntityLocation location = null;

  @JsonProperty("background")
  private String background = null;

  @JsonProperty("portrait")
  private String portrait = null;

  @JsonProperty("gold")
  private Boolean gold = false;

  @JsonProperty("boardPosition")
  private Integer boardPosition = null;

  @JsonProperty("owner")
  private Integer owner = -1;

  @JsonProperty("heroClass")
  private String heroClass = null;

  @JsonProperty("baseHp")
  private Integer baseHp = null;

  @JsonProperty("hp")
  private Integer hp = null;

  @JsonProperty("durability")
  private Integer durability = null;

  @JsonProperty("maxHp")
  private Integer maxHp = null;

  @JsonProperty("baseAttack")
  private Integer baseAttack = null;

  @JsonProperty("attack")
  private Integer attack = null;

  @JsonProperty("baseManaCost")
  private Integer baseManaCost = null;

  @JsonProperty("manaCost")
  private Integer manaCost = null;

  @JsonProperty("armor")
  private Integer armor = null;

  @JsonProperty("destroyed")
  private Boolean destroyed = false;

  @JsonProperty("summoningSickness")
  private Boolean summoningSickness = false;

  @JsonProperty("frozen")
  private Boolean frozen = false;

  @JsonProperty("uncensored")
  private Boolean uncensored = false;

  @JsonProperty("deflect")
  private Boolean deflect = false;

  @JsonProperty("silenced")
  private Boolean silenced = false;

  @JsonProperty("windfury")
  private Boolean windfury = false;

  @JsonProperty("permanent")
  private Boolean permanent = false;

  @JsonProperty("collectible")
  private Boolean collectible = false;

  @JsonProperty("taunt")
  private Boolean taunt = false;

  @JsonProperty("spellDamage")
  private Integer spellDamage = null;

  @JsonProperty("charge")
  private Boolean charge = false;

  @JsonProperty("rush")
  private Boolean rush = false;

  @JsonProperty("lifesteal")
  private Boolean lifesteal = false;

  @JsonProperty("poisonous")
  private Boolean poisonous = false;

  @JsonProperty("enraged")
  private Boolean enraged = false;

  @JsonProperty("battlecry")
  private Boolean battlecry = false;

  @JsonProperty("deathrattles")
  private Boolean deathrattles = false;

  @JsonProperty("immune")
  private Boolean immune = false;

  @JsonProperty("divineShield")
  private Boolean divineShield = false;

  @JsonProperty("stealth")
  private Boolean stealth = false;

  @JsonProperty("combo")
  private Boolean combo = false;

  @JsonProperty("overload")
  private Integer overload = null;

  @JsonProperty("chooseOne")
  private Boolean chooseOne = false;

  @JsonProperty("untargetableBySpells")
  private Boolean untargetableBySpells = false;

  @JsonProperty("cannotAttack")
  private Boolean cannotAttack = false;

  @JsonProperty("underAura")
  private Boolean underAura = false;

  @JsonProperty("customRenderer")
  private String customRenderer = null;

  @JsonProperty("customData")
  private String customData = null;

  @JsonProperty("playable")
  private Boolean playable = false;

  @JsonProperty("conditionMet")
  private Boolean conditionMet = false;

  @JsonProperty("mana")
  private Integer mana = null;

  @JsonProperty("maxMana")
  private Integer maxMana = null;

  @JsonProperty("lockedMana")
  private Integer lockedMana = null;

  @JsonProperty("hostsTrigger")
  private Boolean hostsTrigger = false;

  @JsonProperty("note")
  private String note = null;

  /**
   * When not null, indicates this card entity has a specified type.
   */
  public enum CardTypeEnum {
    HERO("HERO"),
    
    MINION("MINION"),
    
    SPELL("SPELL"),
    
    WEAPON("WEAPON"),
    
    HERO_POWER("HERO_POWER"),
    
    CHOOSE_ONE("CHOOSE_ONE"),
    
    CLASS("CLASS");

    private String value;

    CardTypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static CardTypeEnum fromValue(String text) {
      for (CardTypeEnum b : CardTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
  }

  @JsonProperty("cardType")
  private CardTypeEnum cardType = null;

  @JsonProperty("tribe")
  private String tribe = null;

  @JsonProperty("fires")
  private Integer fires = 0;

  @JsonProperty("countUntilCast")
  private Integer countUntilCast = 0;

  @JsonProperty("cardSet")
  private String cardSet = null;

  /**
   * The rarity of the card 
   */
  public enum RarityEnum {
    FREE("FREE"),
    
    COMMON("COMMON"),
    
    RARE("RARE"),
    
    EPIC("EPIC"),
    
    LEGENDARY("LEGENDARY"),
    
    ALLIANCE("ALLIANCE");

    private String value;

    RarityEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static RarityEnum fromValue(String text) {
      for (RarityEnum b : RarityEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
  }

  @JsonProperty("rarity")
  private RarityEnum rarity = null;

  @JsonProperty("gameStarted")
  private Boolean gameStarted = false;

  @JsonProperty("color")
  private List<Float> color = null;

  @JsonProperty("blackText")
  private Boolean blackText = false;

  public EntityState location(EntityLocation location) {
    this.location = location;
    return this;
  }

   /**
   * Get location
   * @return location
  **/
  @ApiModelProperty(value = "")
  public EntityLocation getLocation() {
    return location;
  }

  public void setLocation(EntityLocation location) {
    this.location = location;
  }

  public EntityState background(String background) {
    this.background = background;
    return this;
  }

   /**
   * When not null, override the default background for this entity&#39;s card ID with this key corresponding to backgrounds from the server. 
   * @return background
  **/
  @ApiModelProperty(value = "When not null, override the default background for this entity's card ID with this key corresponding to backgrounds from the server. ")
  public String getBackground() {
    return background;
  }

  public void setBackground(String background) {
    this.background = background;
  }

  public EntityState portrait(String portrait) {
    this.portrait = portrait;
    return this;
  }

   /**
   * When not null, override the default portrait for this entity&#39;s card ID with this key corresponding to portraits from the server. 
   * @return portrait
  **/
  @ApiModelProperty(value = "When not null, override the default portrait for this entity's card ID with this key corresponding to portraits from the server. ")
  public String getPortrait() {
    return portrait;
  }

  public void setPortrait(String portrait) {
    this.portrait = portrait;
  }

  public EntityState gold(Boolean gold) {
    this.gold = gold;
    return this;
  }

   /**
   * Render this entity with a \&quot;gold\&quot; effect.
   * @return gold
  **/
  @ApiModelProperty(value = "Render this entity with a \"gold\" effect.")
  public Boolean isGold() {
    return gold;
  }

  public void setGold(Boolean gold) {
    this.gold = gold;
  }

  public EntityState boardPosition(Integer boardPosition) {
    this.boardPosition = boardPosition;
    return this;
  }

   /**
   * The index of the entity in its zone.
   * @return boardPosition
  **/
  @ApiModelProperty(value = "The index of the entity in its zone.")
  public Integer getBoardPosition() {
    return boardPosition;
  }

  public void setBoardPosition(Integer boardPosition) {
    this.boardPosition = boardPosition;
  }

  public EntityState owner(Integer owner) {
    this.owner = owner;
    return this;
  }

   /**
   * An integer corresponding to the entity&#39;s owner.
   * @return owner
  **/
  @ApiModelProperty(value = "An integer corresponding to the entity's owner.")
  public Integer getOwner() {
    return owner;
  }

  public void setOwner(Integer owner) {
    this.owner = owner;
  }

  public EntityState heroClass(String heroClass) {
    this.heroClass = heroClass;
    return this;
  }

   /**
   * The string enum value that corresponds to this entity&#39;s hero class.
   * @return heroClass
  **/
  @ApiModelProperty(value = "The string enum value that corresponds to this entity's hero class.")
  public String getHeroClass() {
    return heroClass;
  }

  public void setHeroClass(String heroClass) {
    this.heroClass = heroClass;
  }

  public EntityState baseHp(Integer baseHp) {
    this.baseHp = baseHp;
    return this;
  }

   /**
   * The base hitpoints of the entity.
   * @return baseHp
  **/
  @ApiModelProperty(value = "The base hitpoints of the entity.")
  public Integer getBaseHp() {
    return baseHp;
  }

  public void setBaseHp(Integer baseHp) {
    this.baseHp = baseHp;
  }

  public EntityState hp(Integer hp) {
    this.hp = hp;
    return this;
  }

   /**
   * The current hitpoints of the entity. Conventionally, this value should be rendered on the hitpoints token. 
   * @return hp
  **/
  @ApiModelProperty(value = "The current hitpoints of the entity. Conventionally, this value should be rendered on the hitpoints token. ")
  public Integer getHp() {
    return hp;
  }

  public void setHp(Integer hp) {
    this.hp = hp;
  }

  public EntityState durability(Integer durability) {
    this.durability = durability;
    return this;
  }

   /**
   * The durability (number of uses) that the weapon still has.
   * @return durability
  **/
  @ApiModelProperty(value = "The durability (number of uses) that the weapon still has.")
  public Integer getDurability() {
    return durability;
  }

  public void setDurability(Integer durability) {
    this.durability = durability;
  }

  public EntityState maxHp(Integer maxHp) {
    this.maxHp = maxHp;
    return this;
  }

   /**
   * The maximum number of hitpoints this entity can have.
   * @return maxHp
  **/
  @ApiModelProperty(value = "The maximum number of hitpoints this entity can have.")
  public Integer getMaxHp() {
    return maxHp;
  }

  public void setMaxHp(Integer maxHp) {
    this.maxHp = maxHp;
  }

  public EntityState baseAttack(Integer baseAttack) {
    this.baseAttack = baseAttack;
    return this;
  }

   /**
   * The entity&#39;s base attack value.
   * @return baseAttack
  **/
  @ApiModelProperty(value = "The entity's base attack value.")
  public Integer getBaseAttack() {
    return baseAttack;
  }

  public void setBaseAttack(Integer baseAttack) {
    this.baseAttack = baseAttack;
  }

  public EntityState attack(Integer attack) {
    this.attack = attack;
    return this;
  }

   /**
   * The entity&#39;s current attack value. Conventionally, this value should be rendered on the attack token. 
   * @return attack
  **/
  @ApiModelProperty(value = "The entity's current attack value. Conventionally, this value should be rendered on the attack token. ")
  public Integer getAttack() {
    return attack;
  }

  public void setAttack(Integer attack) {
    this.attack = attack;
  }

  public EntityState baseManaCost(Integer baseManaCost) {
    this.baseManaCost = baseManaCost;
    return this;
  }

   /**
   * The entity&#39;s base mana cost. 
   * @return baseManaCost
  **/
  @ApiModelProperty(value = "The entity's base mana cost. ")
  public Integer getBaseManaCost() {
    return baseManaCost;
  }

  public void setBaseManaCost(Integer baseManaCost) {
    this.baseManaCost = baseManaCost;
  }

  public EntityState manaCost(Integer manaCost) {
    this.manaCost = manaCost;
    return this;
  }

   /**
   * The entity&#39;s current mana cost. Conventionally, this value should be rendered on the mana token. 
   * @return manaCost
  **/
  @ApiModelProperty(value = "The entity's current mana cost. Conventionally, this value should be rendered on the mana token. ")
  public Integer getManaCost() {
    return manaCost;
  }

  public void setManaCost(Integer manaCost) {
    this.manaCost = manaCost;
  }

  public EntityState armor(Integer armor) {
    this.armor = armor;
    return this;
  }

   /**
   * The entity&#39;s armor. Conventionally, this value should be rendered on a hero entity&#39;s armor token. 
   * @return armor
  **/
  @ApiModelProperty(value = "The entity's armor. Conventionally, this value should be rendered on a hero entity's armor token. ")
  public Integer getArmor() {
    return armor;
  }

  public void setArmor(Integer armor) {
    this.armor = armor;
  }

  public EntityState destroyed(Boolean destroyed) {
    this.destroyed = destroyed;
    return this;
  }

   /**
   * When true, indicates that this entity is destroyed. During event evaluation, an entity can be destroyed but still in a zone other than the graveyard; render a death icon over the entity when it is so marked. 
   * @return destroyed
  **/
  @ApiModelProperty(value = "When true, indicates that this entity is destroyed. During event evaluation, an entity can be destroyed but still in a zone other than the graveyard; render a death icon over the entity when it is so marked. ")
  public Boolean isDestroyed() {
    return destroyed;
  }

  public void setDestroyed(Boolean destroyed) {
    this.destroyed = destroyed;
  }

  public EntityState summoningSickness(Boolean summoningSickness) {
    this.summoningSickness = summoningSickness;
    return this;
  }

   /**
   * When true, the entity cannot attack this turn because it has \&quot;summoning sickness,\&quot; or a disability related to the first turn the entity came into play. Typically rendered with snooze icons. 
   * @return summoningSickness
  **/
  @ApiModelProperty(value = "When true, the entity cannot attack this turn because it has \"summoning sickness,\" or a disability related to the first turn the entity came into play. Typically rendered with snooze icons. ")
  public Boolean isSummoningSickness() {
    return summoningSickness;
  }

  public void setSummoningSickness(Boolean summoningSickness) {
    this.summoningSickness = summoningSickness;
  }

  public EntityState frozen(Boolean frozen) {
    this.frozen = frozen;
    return this;
  }

   /**
   * When true, the entity cannot attack because a spell casted on it prevents it so, until the next turn when it would normally be able to attack. 
   * @return frozen
  **/
  @ApiModelProperty(value = "When true, the entity cannot attack because a spell casted on it prevents it so, until the next turn when it would normally be able to attack. ")
  public Boolean isFrozen() {
    return frozen;
  }

  public void setFrozen(Boolean frozen) {
    this.frozen = frozen;
  }

  public EntityState uncensored(Boolean uncensored) {
    this.uncensored = uncensored;
    return this;
  }

   /**
   * When true, indicates that this entity that is ordinarily censored to this user is not. It can be \&quot;flipped\&quot; and shown to the opponent. 
   * @return uncensored
  **/
  @ApiModelProperty(value = "When true, indicates that this entity that is ordinarily censored to this user is not. It can be \"flipped\" and shown to the opponent. ")
  public Boolean isUncensored() {
    return uncensored;
  }

  public void setUncensored(Boolean uncensored) {
    this.uncensored = uncensored;
  }

  public EntityState deflect(Boolean deflect) {
    this.deflect = deflect;
    return this;
  }

   /**
   * When true, the entity&#39;s first incoming hit will hit its owner rather than itself. 
   * @return deflect
  **/
  @ApiModelProperty(value = "When true, the entity's first incoming hit will hit its owner rather than itself. ")
  public Boolean isDeflect() {
    return deflect;
  }

  public void setDeflect(Boolean deflect) {
    this.deflect = deflect;
  }

  public EntityState silenced(Boolean silenced) {
    this.silenced = silenced;
    return this;
  }

   /**
   * Indicates that the entity was silenced. 
   * @return silenced
  **/
  @ApiModelProperty(value = "Indicates that the entity was silenced. ")
  public Boolean isSilenced() {
    return silenced;
  }

  public void setSilenced(Boolean silenced) {
    this.silenced = silenced;
  }

  public EntityState windfury(Boolean windfury) {
    this.windfury = windfury;
    return this;
  }

   /**
   * Indicates the entity can attack twice a turn. 
   * @return windfury
  **/
  @ApiModelProperty(value = "Indicates the entity can attack twice a turn. ")
  public Boolean isWindfury() {
    return windfury;
  }

  public void setWindfury(Boolean windfury) {
    this.windfury = windfury;
  }

  public EntityState permanent(Boolean permanent) {
    this.permanent = permanent;
    return this;
  }

   /**
   * Indicates the entity is an on-battlefield permanent. 
   * @return permanent
  **/
  @ApiModelProperty(value = "Indicates the entity is an on-battlefield permanent. ")
  public Boolean isPermanent() {
    return permanent;
  }

  public void setPermanent(Boolean permanent) {
    this.permanent = permanent;
  }

  public EntityState collectible(Boolean collectible) {
    this.collectible = collectible;
    return this;
  }

   /**
   * Indicates the card is collectible - valid for putting into decks. 
   * @return collectible
  **/
  @ApiModelProperty(value = "Indicates the card is collectible - valid for putting into decks. ")
  public Boolean isCollectible() {
    return collectible;
  }

  public void setCollectible(Boolean collectible) {
    this.collectible = collectible;
  }

  public EntityState taunt(Boolean taunt) {
    this.taunt = taunt;
    return this;
  }

   /**
   * Indicates the entity and other taunt entities must be targeted by enemy actors first during an opponent&#39;s physical attack action targeting. 
   * @return taunt
  **/
  @ApiModelProperty(value = "Indicates the entity and other taunt entities must be targeted by enemy actors first during an opponent's physical attack action targeting. ")
  public Boolean isTaunt() {
    return taunt;
  }

  public void setTaunt(Boolean taunt) {
    this.taunt = taunt;
  }

  public EntityState spellDamage(Integer spellDamage) {
    this.spellDamage = spellDamage;
    return this;
  }

   /**
   * Indicates the amount of additional spell damage this entity gives its owning player. 
   * @return spellDamage
  **/
  @ApiModelProperty(value = "Indicates the amount of additional spell damage this entity gives its owning player. ")
  public Integer getSpellDamage() {
    return spellDamage;
  }

  public void setSpellDamage(Integer spellDamage) {
    this.spellDamage = spellDamage;
  }

  public EntityState charge(Boolean charge) {
    this.charge = charge;
    return this;
  }

   /**
   * When true, the entity can attack the same turn it is summoned. 
   * @return charge
  **/
  @ApiModelProperty(value = "When true, the entity can attack the same turn it is summoned. ")
  public Boolean isCharge() {
    return charge;
  }

  public void setCharge(Boolean charge) {
    this.charge = charge;
  }

  public EntityState rush(Boolean rush) {
    this.rush = rush;
    return this;
  }

   /**
   * When true, the entity can attack a minion the same turn it is summoned. 
   * @return rush
  **/
  @ApiModelProperty(value = "When true, the entity can attack a minion the same turn it is summoned. ")
  public Boolean isRush() {
    return rush;
  }

  public void setRush(Boolean rush) {
    this.rush = rush;
  }

  public EntityState lifesteal(Boolean lifesteal) {
    this.lifesteal = lifesteal;
    return this;
  }

   /**
   * When true, the entity heals its owner when it deals damage. 
   * @return lifesteal
  **/
  @ApiModelProperty(value = "When true, the entity heals its owner when it deals damage. ")
  public Boolean isLifesteal() {
    return lifesteal;
  }

  public void setLifesteal(Boolean lifesteal) {
    this.lifesteal = lifesteal;
  }

  public EntityState poisonous(Boolean poisonous) {
    this.poisonous = poisonous;
    return this;
  }

   /**
   * When true, the entity will destroy any target it damages. 
   * @return poisonous
  **/
  @ApiModelProperty(value = "When true, the entity will destroy any target it damages. ")
  public Boolean isPoisonous() {
    return poisonous;
  }

  public void setPoisonous(Boolean poisonous) {
    this.poisonous = poisonous;
  }

  public EntityState enraged(Boolean enraged) {
    this.enraged = enraged;
    return this;
  }

   /**
   * When true, this entity is under the influence of \&quot;enrage,\&quot; or a bonus when it takes damage the first time. 
   * @return enraged
  **/
  @ApiModelProperty(value = "When true, this entity is under the influence of \"enrage,\" or a bonus when it takes damage the first time. ")
  public Boolean isEnraged() {
    return enraged;
  }

  public void setEnraged(Boolean enraged) {
    this.enraged = enraged;
  }

  public EntityState battlecry(Boolean battlecry) {
    this.battlecry = battlecry;
    return this;
  }

   /**
   * When true, this entity has an effect that gets triggered when it is played from the hand. 
   * @return battlecry
  **/
  @ApiModelProperty(value = "When true, this entity has an effect that gets triggered when it is played from the hand. ")
  public Boolean isBattlecry() {
    return battlecry;
  }

  public void setBattlecry(Boolean battlecry) {
    this.battlecry = battlecry;
  }

  public EntityState deathrattles(Boolean deathrattles) {
    this.deathrattles = deathrattles;
    return this;
  }

   /**
   * When true, this entity has an effect that gets triggered when it is destroyed. 
   * @return deathrattles
  **/
  @ApiModelProperty(value = "When true, this entity has an effect that gets triggered when it is destroyed. ")
  public Boolean isDeathrattles() {
    return deathrattles;
  }

  public void setDeathrattles(Boolean deathrattles) {
    this.deathrattles = deathrattles;
  }

  public EntityState immune(Boolean immune) {
    this.immune = immune;
    return this;
  }

   /**
   * Indicates the entity does not take damage. 
   * @return immune
  **/
  @ApiModelProperty(value = "Indicates the entity does not take damage. ")
  public Boolean isImmune() {
    return immune;
  }

  public void setImmune(Boolean immune) {
    this.immune = immune;
  }

  public EntityState divineShield(Boolean divineShield) {
    this.divineShield = divineShield;
    return this;
  }

   /**
   * When true, the entity will take no loss in hitpoints the first time it would ordinarily take damage. 
   * @return divineShield
  **/
  @ApiModelProperty(value = "When true, the entity will take no loss in hitpoints the first time it would ordinarily take damage. ")
  public Boolean isDivineShield() {
    return divineShield;
  }

  public void setDivineShield(Boolean divineShield) {
    this.divineShield = divineShield;
  }

  public EntityState stealth(Boolean stealth) {
    this.stealth = stealth;
    return this;
  }

   /**
   * When true, the minion cannot be targeted by the opponent until the entity attacks for the first time. 
   * @return stealth
  **/
  @ApiModelProperty(value = "When true, the minion cannot be targeted by the opponent until the entity attacks for the first time. ")
  public Boolean isStealth() {
    return stealth;
  }

  public void setStealth(Boolean stealth) {
    this.stealth = stealth;
  }

  public EntityState combo(Boolean combo) {
    this.combo = combo;
    return this;
  }

   /**
   * Indicates this minion has a combo effect. 
   * @return combo
  **/
  @ApiModelProperty(value = "Indicates this minion has a combo effect. ")
  public Boolean isCombo() {
    return combo;
  }

  public void setCombo(Boolean combo) {
    this.combo = combo;
  }

  public EntityState overload(Integer overload) {
    this.overload = overload;
    return this;
  }

   /**
   * Indicates the amount of mana that would be locked if this card were played. 
   * @return overload
  **/
  @ApiModelProperty(value = "Indicates the amount of mana that would be locked if this card were played. ")
  public Integer getOverload() {
    return overload;
  }

  public void setOverload(Integer overload) {
    this.overload = overload;
  }

  public EntityState chooseOne(Boolean chooseOne) {
    this.chooseOne = chooseOne;
    return this;
  }

   /**
   * Indicates this card has a choose-one effect. 
   * @return chooseOne
  **/
  @ApiModelProperty(value = "Indicates this card has a choose-one effect. ")
  public Boolean isChooseOne() {
    return chooseOne;
  }

  public void setChooseOne(Boolean chooseOne) {
    this.chooseOne = chooseOne;
  }

  public EntityState untargetableBySpells(Boolean untargetableBySpells) {
    this.untargetableBySpells = untargetableBySpells;
    return this;
  }

   /**
   * Indicates this entity cannot be targeted by spells. 
   * @return untargetableBySpells
  **/
  @ApiModelProperty(value = "Indicates this entity cannot be targeted by spells. ")
  public Boolean isUntargetableBySpells() {
    return untargetableBySpells;
  }

  public void setUntargetableBySpells(Boolean untargetableBySpells) {
    this.untargetableBySpells = untargetableBySpells;
  }

  public EntityState cannotAttack(Boolean cannotAttack) {
    this.cannotAttack = cannotAttack;
    return this;
  }

   /**
   * When true, indicates this minion cannot attack, even though it normally can.
   * @return cannotAttack
  **/
  @ApiModelProperty(value = "When true, indicates this minion cannot attack, even though it normally can.")
  public Boolean isCannotAttack() {
    return cannotAttack;
  }

  public void setCannotAttack(Boolean cannotAttack) {
    this.cannotAttack = cannotAttack;
  }

  public EntityState underAura(Boolean underAura) {
    this.underAura = underAura;
    return this;
  }

   /**
   * When true, indicates this minion is benefiting from the aura of another effect.
   * @return underAura
  **/
  @ApiModelProperty(value = "When true, indicates this minion is benefiting from the aura of another effect.")
  public Boolean isUnderAura() {
    return underAura;
  }

  public void setUnderAura(Boolean underAura) {
    this.underAura = underAura;
  }

  public EntityState customRenderer(String customRenderer) {
    this.customRenderer = customRenderer;
    return this;
  }

   /**
   * Get customRenderer
   * @return customRenderer
  **/
  @ApiModelProperty(value = "")
  public String getCustomRenderer() {
    return customRenderer;
  }

  public void setCustomRenderer(String customRenderer) {
    this.customRenderer = customRenderer;
  }

  public EntityState customData(String customData) {
    this.customData = customData;
    return this;
  }

   /**
   * Get customData
   * @return customData
  **/
  @ApiModelProperty(value = "")
  public String getCustomData() {
    return customData;
  }

  public void setCustomData(String customData) {
    this.customData = customData;
  }

  public EntityState playable(Boolean playable) {
    this.playable = playable;
    return this;
  }

   /**
   * When true, indicates the card can be played, or the hero / minion can initiate a physical attack.
   * @return playable
  **/
  @ApiModelProperty(value = "When true, indicates the card can be played, or the hero / minion can initiate a physical attack.")
  public Boolean isPlayable() {
    return playable;
  }

  public void setPlayable(Boolean playable) {
    this.playable = playable;
  }

  public EntityState conditionMet(Boolean conditionMet) {
    this.conditionMet = conditionMet;
    return this;
  }

   /**
   * When true, indicates that a condition written on the card is met and the player should be informed.
   * @return conditionMet
  **/
  @ApiModelProperty(value = "When true, indicates that a condition written on the card is met and the player should be informed.")
  public Boolean isConditionMet() {
    return conditionMet;
  }

  public void setConditionMet(Boolean conditionMet) {
    this.conditionMet = conditionMet;
  }

  public EntityState mana(Integer mana) {
    this.mana = mana;
    return this;
  }

   /**
   * The player&#39;s current mana.
   * @return mana
  **/
  @ApiModelProperty(value = "The player's current mana.")
  public Integer getMana() {
    return mana;
  }

  public void setMana(Integer mana) {
    this.mana = mana;
  }

  public EntityState maxMana(Integer maxMana) {
    this.maxMana = maxMana;
    return this;
  }

   /**
   * The player&#39;s maximum amount of mana.
   * @return maxMana
  **/
  @ApiModelProperty(value = "The player's maximum amount of mana.")
  public Integer getMaxMana() {
    return maxMana;
  }

  public void setMaxMana(Integer maxMana) {
    this.maxMana = maxMana;
  }

  public EntityState lockedMana(Integer lockedMana) {
    this.lockedMana = lockedMana;
    return this;
  }

   /**
   * The amount of mana that was locked due to overload.
   * @return lockedMana
  **/
  @ApiModelProperty(value = "The amount of mana that was locked due to overload.")
  public Integer getLockedMana() {
    return lockedMana;
  }

  public void setLockedMana(Integer lockedMana) {
    this.lockedMana = lockedMana;
  }

  public EntityState hostsTrigger(Boolean hostsTrigger) {
    this.hostsTrigger = hostsTrigger;
    return this;
  }

   /**
   * When true, indicates this entity has an effect that triggers on game events.
   * @return hostsTrigger
  **/
  @ApiModelProperty(value = "When true, indicates this entity has an effect that triggers on game events.")
  public Boolean isHostsTrigger() {
    return hostsTrigger;
  }

  public void setHostsTrigger(Boolean hostsTrigger) {
    this.hostsTrigger = hostsTrigger;
  }

  public EntityState note(String note) {
    this.note = note;
    return this;
  }

   /**
   * A renderable note attached to this entity.
   * @return note
  **/
  @ApiModelProperty(value = "A renderable note attached to this entity.")
  public String getNote() {
    return note;
  }

  public void setNote(String note) {
    this.note = note;
  }

  public EntityState cardType(CardTypeEnum cardType) {
    this.cardType = cardType;
    return this;
  }

   /**
   * When not null, indicates this card entity has a specified type.
   * @return cardType
  **/
  @ApiModelProperty(value = "When not null, indicates this card entity has a specified type.")
  public CardTypeEnum getCardType() {
    return cardType;
  }

  public void setCardType(CardTypeEnum cardType) {
    this.cardType = cardType;
  }

  public EntityState tribe(String tribe) {
    this.tribe = tribe;
    return this;
  }

   /**
   * When not null, indicates the card&#39;s tribe/race. Typically only minions have this field set.
   * @return tribe
  **/
  @ApiModelProperty(value = "When not null, indicates the card's tribe/race. Typically only minions have this field set.")
  public String getTribe() {
    return tribe;
  }

  public void setTribe(String tribe) {
    this.tribe = tribe;
  }

  public EntityState fires(Integer fires) {
    this.fires = fires;
    return this;
  }

   /**
   * The number of times this enchantment (secret, quest or trigger on card) has fired.
   * @return fires
  **/
  @ApiModelProperty(value = "The number of times this enchantment (secret, quest or trigger on card) has fired.")
  public Integer getFires() {
    return fires;
  }

  public void setFires(Integer fires) {
    this.fires = fires;
  }

  public EntityState countUntilCast(Integer countUntilCast) {
    this.countUntilCast = countUntilCast;
    return this;
  }

   /**
   * The number of times this enchantment (secret, quest or trigger on card) must fire before its spell effect is triggered. 
   * @return countUntilCast
  **/
  @ApiModelProperty(value = "The number of times this enchantment (secret, quest or trigger on card) must fire before its spell effect is triggered. ")
  public Integer getCountUntilCast() {
    return countUntilCast;
  }

  public void setCountUntilCast(Integer countUntilCast) {
    this.countUntilCast = countUntilCast;
  }

  public EntityState cardSet(String cardSet) {
    this.cardSet = cardSet;
    return this;
  }

   /**
   * The card expansion set this entity belongs to. 
   * @return cardSet
  **/
  @ApiModelProperty(value = "The card expansion set this entity belongs to. ")
  public String getCardSet() {
    return cardSet;
  }

  public void setCardSet(String cardSet) {
    this.cardSet = cardSet;
  }

  public EntityState rarity(RarityEnum rarity) {
    this.rarity = rarity;
    return this;
  }

   /**
   * The rarity of the card 
   * @return rarity
  **/
  @ApiModelProperty(value = "The rarity of the card ")
  public RarityEnum getRarity() {
    return rarity;
  }

  public void setRarity(RarityEnum rarity) {
    this.rarity = rarity;
  }

  public EntityState gameStarted(Boolean gameStarted) {
    this.gameStarted = gameStarted;
    return this;
  }

   /**
   * For player entities, indicates whether or not the player has finished the mulligan phase and is awaiting the other player to finish mulligan or, if both players have this field as true, indicates the game has begun on turn 0. 
   * @return gameStarted
  **/
  @ApiModelProperty(value = "For player entities, indicates whether or not the player has finished the mulligan phase and is awaiting the other player to finish mulligan or, if both players have this field as true, indicates the game has begun on turn 0. ")
  public Boolean isGameStarted() {
    return gameStarted;
  }

  public void setGameStarted(Boolean gameStarted) {
    this.gameStarted = gameStarted;
  }

  public EntityState color(List<Float> color) {
    this.color = color;
    return this;
  }

  public EntityState addColorItem(Float colorItem) {
    if (this.color == null) {
      this.color = new ArrayList<>();
    }
    this.color.add(colorItem);
    return this;
  }

   /**
   * The color for the class 
   * @return color
  **/
  @ApiModelProperty(value = "The color for the class ")
  public List<Float> getColor() {
    return color;
  }

  public void setColor(List<Float> color) {
    this.color = color;
  }

  public EntityState blackText(Boolean blackText) {
    this.blackText = blackText;
    return this;
  }

   /**
   * Whether the class should use black text instead of the default white 
   * @return blackText
  **/
  @ApiModelProperty(value = "Whether the class should use black text instead of the default white ")
  public Boolean isBlackText() {
    return blackText;
  }

  public void setBlackText(Boolean blackText) {
    this.blackText = blackText;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EntityState entityState = (EntityState) o;
    return Objects.equals(this.location, entityState.location) &&
        Objects.equals(this.background, entityState.background) &&
        Objects.equals(this.portrait, entityState.portrait) &&
        Objects.equals(this.gold, entityState.gold) &&
        Objects.equals(this.boardPosition, entityState.boardPosition) &&
        Objects.equals(this.owner, entityState.owner) &&
        Objects.equals(this.heroClass, entityState.heroClass) &&
        Objects.equals(this.baseHp, entityState.baseHp) &&
        Objects.equals(this.hp, entityState.hp) &&
        Objects.equals(this.durability, entityState.durability) &&
        Objects.equals(this.maxHp, entityState.maxHp) &&
        Objects.equals(this.baseAttack, entityState.baseAttack) &&
        Objects.equals(this.attack, entityState.attack) &&
        Objects.equals(this.baseManaCost, entityState.baseManaCost) &&
        Objects.equals(this.manaCost, entityState.manaCost) &&
        Objects.equals(this.armor, entityState.armor) &&
        Objects.equals(this.destroyed, entityState.destroyed) &&
        Objects.equals(this.summoningSickness, entityState.summoningSickness) &&
        Objects.equals(this.frozen, entityState.frozen) &&
        Objects.equals(this.uncensored, entityState.uncensored) &&
        Objects.equals(this.deflect, entityState.deflect) &&
        Objects.equals(this.silenced, entityState.silenced) &&
        Objects.equals(this.windfury, entityState.windfury) &&
        Objects.equals(this.permanent, entityState.permanent) &&
        Objects.equals(this.collectible, entityState.collectible) &&
        Objects.equals(this.taunt, entityState.taunt) &&
        Objects.equals(this.spellDamage, entityState.spellDamage) &&
        Objects.equals(this.charge, entityState.charge) &&
        Objects.equals(this.rush, entityState.rush) &&
        Objects.equals(this.lifesteal, entityState.lifesteal) &&
        Objects.equals(this.poisonous, entityState.poisonous) &&
        Objects.equals(this.enraged, entityState.enraged) &&
        Objects.equals(this.battlecry, entityState.battlecry) &&
        Objects.equals(this.deathrattles, entityState.deathrattles) &&
        Objects.equals(this.immune, entityState.immune) &&
        Objects.equals(this.divineShield, entityState.divineShield) &&
        Objects.equals(this.stealth, entityState.stealth) &&
        Objects.equals(this.combo, entityState.combo) &&
        Objects.equals(this.overload, entityState.overload) &&
        Objects.equals(this.chooseOne, entityState.chooseOne) &&
        Objects.equals(this.untargetableBySpells, entityState.untargetableBySpells) &&
        Objects.equals(this.cannotAttack, entityState.cannotAttack) &&
        Objects.equals(this.underAura, entityState.underAura) &&
        Objects.equals(this.customRenderer, entityState.customRenderer) &&
        Objects.equals(this.customData, entityState.customData) &&
        Objects.equals(this.playable, entityState.playable) &&
        Objects.equals(this.conditionMet, entityState.conditionMet) &&
        Objects.equals(this.mana, entityState.mana) &&
        Objects.equals(this.maxMana, entityState.maxMana) &&
        Objects.equals(this.lockedMana, entityState.lockedMana) &&
        Objects.equals(this.hostsTrigger, entityState.hostsTrigger) &&
        Objects.equals(this.note, entityState.note) &&
        Objects.equals(this.cardType, entityState.cardType) &&
        Objects.equals(this.tribe, entityState.tribe) &&
        Objects.equals(this.fires, entityState.fires) &&
        Objects.equals(this.countUntilCast, entityState.countUntilCast) &&
        Objects.equals(this.cardSet, entityState.cardSet) &&
        Objects.equals(this.rarity, entityState.rarity) &&
        Objects.equals(this.gameStarted, entityState.gameStarted) &&
        Objects.equals(this.color, entityState.color) &&
        Objects.equals(this.blackText, entityState.blackText);
  }

  @Override
  public int hashCode() {
    return Objects.hash(location, background, portrait, gold, boardPosition, owner, heroClass, baseHp, hp, durability, maxHp, baseAttack, attack, baseManaCost, manaCost, armor, destroyed, summoningSickness, frozen, uncensored, deflect, silenced, windfury, permanent, collectible, taunt, spellDamage, charge, rush, lifesteal, poisonous, enraged, battlecry, deathrattles, immune, divineShield, stealth, combo, overload, chooseOne, untargetableBySpells, cannotAttack, underAura, customRenderer, customData, playable, conditionMet, mana, maxMana, lockedMana, hostsTrigger, note, cardType, tribe, fires, countUntilCast, cardSet, rarity, gameStarted, color, blackText);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EntityState {\n");
    
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    background: ").append(toIndentedString(background)).append("\n");
    sb.append("    portrait: ").append(toIndentedString(portrait)).append("\n");
    sb.append("    gold: ").append(toIndentedString(gold)).append("\n");
    sb.append("    boardPosition: ").append(toIndentedString(boardPosition)).append("\n");
    sb.append("    owner: ").append(toIndentedString(owner)).append("\n");
    sb.append("    heroClass: ").append(toIndentedString(heroClass)).append("\n");
    sb.append("    baseHp: ").append(toIndentedString(baseHp)).append("\n");
    sb.append("    hp: ").append(toIndentedString(hp)).append("\n");
    sb.append("    durability: ").append(toIndentedString(durability)).append("\n");
    sb.append("    maxHp: ").append(toIndentedString(maxHp)).append("\n");
    sb.append("    baseAttack: ").append(toIndentedString(baseAttack)).append("\n");
    sb.append("    attack: ").append(toIndentedString(attack)).append("\n");
    sb.append("    baseManaCost: ").append(toIndentedString(baseManaCost)).append("\n");
    sb.append("    manaCost: ").append(toIndentedString(manaCost)).append("\n");
    sb.append("    armor: ").append(toIndentedString(armor)).append("\n");
    sb.append("    destroyed: ").append(toIndentedString(destroyed)).append("\n");
    sb.append("    summoningSickness: ").append(toIndentedString(summoningSickness)).append("\n");
    sb.append("    frozen: ").append(toIndentedString(frozen)).append("\n");
    sb.append("    uncensored: ").append(toIndentedString(uncensored)).append("\n");
    sb.append("    deflect: ").append(toIndentedString(deflect)).append("\n");
    sb.append("    silenced: ").append(toIndentedString(silenced)).append("\n");
    sb.append("    windfury: ").append(toIndentedString(windfury)).append("\n");
    sb.append("    permanent: ").append(toIndentedString(permanent)).append("\n");
    sb.append("    collectible: ").append(toIndentedString(collectible)).append("\n");
    sb.append("    taunt: ").append(toIndentedString(taunt)).append("\n");
    sb.append("    spellDamage: ").append(toIndentedString(spellDamage)).append("\n");
    sb.append("    charge: ").append(toIndentedString(charge)).append("\n");
    sb.append("    rush: ").append(toIndentedString(rush)).append("\n");
    sb.append("    lifesteal: ").append(toIndentedString(lifesteal)).append("\n");
    sb.append("    poisonous: ").append(toIndentedString(poisonous)).append("\n");
    sb.append("    enraged: ").append(toIndentedString(enraged)).append("\n");
    sb.append("    battlecry: ").append(toIndentedString(battlecry)).append("\n");
    sb.append("    deathrattles: ").append(toIndentedString(deathrattles)).append("\n");
    sb.append("    immune: ").append(toIndentedString(immune)).append("\n");
    sb.append("    divineShield: ").append(toIndentedString(divineShield)).append("\n");
    sb.append("    stealth: ").append(toIndentedString(stealth)).append("\n");
    sb.append("    combo: ").append(toIndentedString(combo)).append("\n");
    sb.append("    overload: ").append(toIndentedString(overload)).append("\n");
    sb.append("    chooseOne: ").append(toIndentedString(chooseOne)).append("\n");
    sb.append("    untargetableBySpells: ").append(toIndentedString(untargetableBySpells)).append("\n");
    sb.append("    cannotAttack: ").append(toIndentedString(cannotAttack)).append("\n");
    sb.append("    underAura: ").append(toIndentedString(underAura)).append("\n");
    sb.append("    customRenderer: ").append(toIndentedString(customRenderer)).append("\n");
    sb.append("    customData: ").append(toIndentedString(customData)).append("\n");
    sb.append("    playable: ").append(toIndentedString(playable)).append("\n");
    sb.append("    conditionMet: ").append(toIndentedString(conditionMet)).append("\n");
    sb.append("    mana: ").append(toIndentedString(mana)).append("\n");
    sb.append("    maxMana: ").append(toIndentedString(maxMana)).append("\n");
    sb.append("    lockedMana: ").append(toIndentedString(lockedMana)).append("\n");
    sb.append("    hostsTrigger: ").append(toIndentedString(hostsTrigger)).append("\n");
    sb.append("    note: ").append(toIndentedString(note)).append("\n");
    sb.append("    cardType: ").append(toIndentedString(cardType)).append("\n");
    sb.append("    tribe: ").append(toIndentedString(tribe)).append("\n");
    sb.append("    fires: ").append(toIndentedString(fires)).append("\n");
    sb.append("    countUntilCast: ").append(toIndentedString(countUntilCast)).append("\n");
    sb.append("    cardSet: ").append(toIndentedString(cardSet)).append("\n");
    sb.append("    rarity: ").append(toIndentedString(rarity)).append("\n");
    sb.append("    gameStarted: ").append(toIndentedString(gameStarted)).append("\n");
    sb.append("    color: ").append(toIndentedString(color)).append("\n");
    sb.append("    blackText: ").append(toIndentedString(blackText)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

