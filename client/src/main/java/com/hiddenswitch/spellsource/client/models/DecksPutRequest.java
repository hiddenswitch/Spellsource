/**
 * Hidden Switch Spellsource API
 * The Spellsource API for matchmaking, user accounts, collections management and more
 *
 * OpenAPI spec version: 1.0.1
 * Contact: benjamin.s.berman@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.hiddenswitch.spellsource.client.models;

import java.util.Objects;
import com.google.gson.annotations.SerializedName;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;

import java.io.Serializable;
/**
 * This request allows a user to specify a decklist or deck properies for creating a new deck. Whenever a deck list is specified (non-null and not equal to the empty string), the deck list will be preferred. Decks created without a deck list may have no properties specified, and the deck will still be successfully created. 
 */
@ApiModel(description = "This request allows a user to specify a decklist or deck properies for creating a new deck. Whenever a deck list is specified (non-null and not equal to the empty string), the deck list will be preferred. Decks created without a deck list may have no properties specified, and the deck will still be successfully created. ")

public class DecksPutRequest  implements Serializable {
  /**
   * A valid hero class for creating the deck. The appropriate hero card will be chosen for this deck unless otherwise specified.   - BROWN: Druid class.  - GREEN: Hunter class.  - BLUE: Mage class.  - GOLD: Paladin class.  - WHITE: Priest class.  - BLACK: Rogue class.  - SILVER: Shaman class.  - VIOLET: Warlock class.  - RED: Warrior class. 
   */
  public enum HeroClassEnum {
    @SerializedName("BROWN")
    BROWN("BROWN"),
    
    @SerializedName("GREEN")
    GREEN("GREEN"),
    
    @SerializedName("BLUE")
    BLUE("BLUE"),
    
    @SerializedName("GOLD")
    GOLD("GOLD"),
    
    @SerializedName("WHITE")
    WHITE("WHITE"),
    
    @SerializedName("BLACK")
    BLACK("BLACK"),
    
    @SerializedName("SILVER")
    SILVER("SILVER"),
    
    @SerializedName("VIOLET")
    VIOLET("VIOLET"),
    
    @SerializedName("RED")
    RED("RED");

    private String value;

    HeroClassEnum(String value) {
      this.value = value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
  }

  @SerializedName("heroClass")
  private HeroClassEnum heroClass = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("inventoryIds")
  private List<String> inventoryIds = new ArrayList<String>();

  /**
   * The format of this deck. Format specifies which cards are allowable in this deck for validation. It also specifies which cards will appear in discovers during matchmaking.  Currenly, matchmaking occurs between decks of all formats, regardless of your choice of format. The smallest possible format encompassing both decks in a match is selected when the formats of the decks do not match.  Certain queues only support certain formats. Typically, when requesting the listing of queues with matchmakingGet, the queues will specify which current decks can be chosen. 
   */
  public enum FormatEnum {
    @SerializedName("Standard")
    STANDARD("Standard"),
    
    @SerializedName("Wild")
    WILD("Wild"),
    
    @SerializedName("Custom")
    CUSTOM("Custom"),
    
    @SerializedName("Spellsource")
    SPELLSOURCE("Spellsource"),
    
    @SerializedName("All")
    ALL("All");

    private String value;

    FormatEnum(String value) {
      this.value = value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
  }

  @SerializedName("format")
  private FormatEnum format = null;

  @SerializedName("deckList")
  private String deckList = null;

  public DecksPutRequest heroClass(HeroClassEnum heroClass) {
    this.heroClass = heroClass;
    return this;
  }

   /**
   * A valid hero class for creating the deck. The appropriate hero card will be chosen for this deck unless otherwise specified.   - BROWN: Druid class.  - GREEN: Hunter class.  - BLUE: Mage class.  - GOLD: Paladin class.  - WHITE: Priest class.  - BLACK: Rogue class.  - SILVER: Shaman class.  - VIOLET: Warlock class.  - RED: Warrior class. 
   * @return heroClass
  **/
  @ApiModelProperty(example = "null", value = "A valid hero class for creating the deck. The appropriate hero card will be chosen for this deck unless otherwise specified.   - BROWN: Druid class.  - GREEN: Hunter class.  - BLUE: Mage class.  - GOLD: Paladin class.  - WHITE: Priest class.  - BLACK: Rogue class.  - SILVER: Shaman class.  - VIOLET: Warlock class.  - RED: Warrior class. ")
  public HeroClassEnum getHeroClass() {
    return heroClass;
  }

  public void setHeroClass(HeroClassEnum heroClass) {
    this.heroClass = heroClass;
  }

  public DecksPutRequest name(String name) {
    this.name = name;
    return this;
  }

   /**
   * The name of the deck as it will appear in the collections view. Typically, your opponent will not be able to see this name.  Some custom cards interact with specific named decks in your collection. For those purposes, the deck names are case sensitive. When multiple decks share a name, one will be chosen arbitrarily (not at random). 
   * @return name
  **/
  @ApiModelProperty(example = "null", value = "The name of the deck as it will appear in the collections view. Typically, your opponent will not be able to see this name.  Some custom cards interact with specific named decks in your collection. For those purposes, the deck names are case sensitive. When multiple decks share a name, one will be chosen arbitrarily (not at random). ")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public DecksPutRequest inventoryIds(List<String> inventoryIds) {
    this.inventoryIds = inventoryIds;
    return this;
  }

  public DecksPutRequest addInventoryIdsItem(String inventoryIdsItem) {
    this.inventoryIds.add(inventoryIdsItem);
    return this;
  }

   /**
   * Get inventoryIds
   * @return inventoryIds
  **/
  @ApiModelProperty(example = "null", value = "")
  public List<String> getInventoryIds() {
    return inventoryIds;
  }

  public void setInventoryIds(List<String> inventoryIds) {
    this.inventoryIds = inventoryIds;
  }

  public DecksPutRequest format(FormatEnum format) {
    this.format = format;
    return this;
  }

   /**
   * The format of this deck. Format specifies which cards are allowable in this deck for validation. It also specifies which cards will appear in discovers during matchmaking.  Currenly, matchmaking occurs between decks of all formats, regardless of your choice of format. The smallest possible format encompassing both decks in a match is selected when the formats of the decks do not match.  Certain queues only support certain formats. Typically, when requesting the listing of queues with matchmakingGet, the queues will specify which current decks can be chosen. 
   * @return format
  **/
  @ApiModelProperty(example = "null", value = "The format of this deck. Format specifies which cards are allowable in this deck for validation. It also specifies which cards will appear in discovers during matchmaking.  Currenly, matchmaking occurs between decks of all formats, regardless of your choice of format. The smallest possible format encompassing both decks in a match is selected when the formats of the decks do not match.  Certain queues only support certain formats. Typically, when requesting the listing of queues with matchmakingGet, the queues will specify which current decks can be chosen. ")
  public FormatEnum getFormat() {
    return format;
  }

  public void setFormat(FormatEnum format) {
    this.format = format;
  }

  public DecksPutRequest deckList(String deckList) {
    this.deckList = deckList;
    return this;
  }

   /**
   * A community-standard decklist. 
   * @return deckList
  **/
  @ApiModelProperty(example = "null", value = "A community-standard decklist. ")
  public String getDeckList() {
    return deckList;
  }

  public void setDeckList(String deckList) {
    this.deckList = deckList;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DecksPutRequest decksPutRequest = (DecksPutRequest) o;
    return Objects.equals(this.heroClass, decksPutRequest.heroClass) &&
        Objects.equals(this.name, decksPutRequest.name) &&
        Objects.equals(this.inventoryIds, decksPutRequest.inventoryIds) &&
        Objects.equals(this.format, decksPutRequest.format) &&
        Objects.equals(this.deckList, decksPutRequest.deckList);
  }

  @Override
  public int hashCode() {
    return Objects.hash(heroClass, name, inventoryIds, format, deckList);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DecksPutRequest {\n");
    
    sb.append("    heroClass: ").append(toIndentedString(heroClass)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    inventoryIds: ").append(toIndentedString(inventoryIds)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    deckList: ").append(toIndentedString(deckList)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

