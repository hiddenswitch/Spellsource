package net.demilich.metastone.game.spells;

import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import net.demilich.metastone.game.GameContext;
import net.demilich.metastone.game.Player;
import net.demilich.metastone.game.cards.desc.Desc;
import net.demilich.metastone.game.cards.desc.HasDesc;
import net.demilich.metastone.game.cards.desc.HasDescSerializer;
import net.demilich.metastone.game.entities.Entity;
import net.demilich.metastone.game.spells.desc.SpellArg;
import net.demilich.metastone.game.spells.desc.SpellDesc;
import net.demilich.metastone.game.spells.desc.filter.EntityFilter;
import net.demilich.metastone.game.targeting.EntityReference;
import org.slf4j.Logger;

import java.io.Serializable;
import java.util.*;

/**
 * The base class for "spells," or collections of effects in the engine.
 * <p>
 * Spell in this context means something broader than a spell card. It refers to anything that causes changes to the
 * game, like a deathrattle or a triggered effect.
 * <p>
 * To browse all the possible effects, visit the deriving classes of this class.
 * <p>
 * These classes are the value for {@link SpellArg#CLASS}, i.e., what you write after {@code "class": ...} in the card
 * JSON for spell objects. Each string in the {@code "class"} values corresponds exactly to a subclass of this class.
 */
@JsonSerialize(using = HasDescSerializer.class)
public abstract class Spell implements Serializable, HasDesc<SpellDesc> {

	private SpellDesc desc;

	/**
	 * Arguments common to all spells that should not be considered invalid.
	 */
	private static final Set<SpellArg> COMMON_ARGS = EnumSet.of(
			SpellArg.CLASS,
			SpellArg.FILTER,
			SpellArg.TARGET,
			SpellArg.NAME,
			SpellArg.DESCRIPTION,
			SpellArg.RANDOM_TARGET,
			SpellArg.TARGET_PLAYER,
			SpellArg.SPELL,
			SpellArg.BOARD_POSITION_RELATIVE,
			SpellArg.BOARD_POSITION_ABSOLUTE,
			SpellArg.AFTERMATH_ID,
			// Included because the DiscoverSpell adds it to the spell that is cast for the chosen card
			SpellArg.CARD);

	/**
	 * Casts a spell for the given arguments.
	 * <p>
	 * If there is at least one valid target in {@code targets} and {@link SpellArg#RANDOM_TARGET} is {@code true}, a
	 * single target from the list will be chosen at random.
	 * <p>
	 * If {@code targets} is {@code null}, this is a spell that does not ordinarily receive targets, so it will be cast
	 * once.
	 * <p>
	 * If {@code targets.size()} is {@code 0}, this spell takes targets but none were found, so the spell is not cast.
	 * <p>
	 * The {@link EntityFilter} specified in {@link SpellArg#FILTER} is applied to the list of targets to filter it.
	 * Therefore, this spell casting code is responsible for interpreting the {@link SpellArg#FILTER} and {@link
	 * SpellArg#RANDOM_TARGET} attributes of a {@link SpellDesc}.
	 * <p>
	 * Typically the {@code targets} list is generated by either using the player's single target choice from a
	 * combination of the spell or battlecry's {@link net.demilich.metastone.game.targeting.TargetSelection} applied
	 * through a {@link SpellArg#FILTER} (resulting in a list of length one), or the resolved {@link SpellArg#TARGET}
	 * predefined target reference (usually a group reference) resulting in a list of length zero or greater.
	 *
	 * @param context The game context
	 * @param player  The casting player. This can be overridden by the {@link SpellArg#TARGET_PLAYER} arg in the {@code
	 *                desc}.
	 * @param desc    The spell description
	 * @param source  The source entity of this spell cast
	 * @param targets A list of targets
	 * @see SpellUtils#getValidTargets(GameContext, Player, List, EntityFilter, Entity) for the logic which filters the
	 * 		targets argument.
	 */
	public void cast(GameContext context, Player player, SpellDesc desc, Entity source, List<Entity> targets) {
		// no target specified, cast the spell once with target NULL
		if (targets == null) {
			castForPlayer(context, player, desc, source, null);
			return;
		}

		EntityFilter targetFilter = desc.getEntityFilter();
		List<Entity> validTargets = SpellUtils.getValidTargets(context, player, targets, targetFilter, source);
		// there is at least one valid target and the RANDOM_TARGET flag is set,
		// pick one randomly
		if (validTargets.size() > 0 && desc.getBool(SpellArg.RANDOM_TARGET)) {
			Entity target = context.getLogic().getRandom(validTargets);
			castForPlayer(context, player, desc, source, target);
		} else {
			// there is at least one target and RANDOM_TARGET flag is not set,
			// cast in on all targets

			for (Entity target : validTargets) {
				final EntityReference reference = target == null ? EntityReference.NONE : target.getReference();
				context.getSpellTargetStack().push(reference);
				castForPlayer(context, player, desc, source, target);
				context.getSpellTargetStack().pop();
			}
		}
	}

	/**
	 * Casts this spell on behalf of the specified player to the specified target.
	 * <p>
	 * When {@link TargetPlayer#BOTH} is specified by the {@link SpellArg#TARGET_PLAYER} in the {@code desc}, this effect
	 * occurs twice: first for the initiating player and then for that player's opponent.
	 *
	 * @param context
	 * @param player
	 * @param desc
	 * @param source
	 * @param target
	 */
	protected void castForPlayer(GameContext context, Player player, SpellDesc desc, Entity source, Entity target) {
		TargetPlayer targetPlayer = desc.getTargetPlayer();
		if (targetPlayer == null) {
			targetPlayer = TargetPlayer.SELF;
		}
		Player opponent = context.getOpponent(player);
		switch (targetPlayer) {
			case BOTH:
				onCast(context, player, desc, source, target);
				onCast(context, opponent, desc, source, target);
				break;
			case OPPONENT:
				onCast(context, opponent, desc, source, target);
				break;
			case SELF:
				onCast(context, player, desc, source, target);
				break;
			case OWNER:
				onCast(context, context.getPlayer(target.getOwner()), desc, source, target);
				break;
			case ACTIVE:
				onCast(context, context.getActivePlayer(), desc, source, target);
				break;
			case INACTIVE:
				onCast(context, context.getOpponent(context.getActivePlayer()), desc, source, target);
				break;
			case PLAYER_1:
				onCast(context, context.getPlayer1(), desc, source, target);
				break;
			case PLAYER_2:
				onCast(context, context.getPlayer2(), desc, source, target);
				break;
			default:
				break;
		}
	}

	/**
	 * Implementations of {@code onCast} are the meat-and-bones of a spell's effects. This should actually call a variety
	 * of methods in {@link net.demilich.metastone.game.logic.GameLogic}, generate cards using {@link
	 * SpellUtils#getCards(GameContext, Player, Entity, Entity, SpellDesc)}, interpret {@link SpellArg} keys in the {@code
	 * desc}, etc.
	 * <p>
	 * Observe that subclasses of {@code Spell} mostly just need to implement this function. Also, observe that instances
	 * of {@code Spell} are stateless: all the state is provided as arguments to this function.
	 *
	 * @param context The game context
	 * @param player  The casting player
	 * @param desc    The collection of {@link SpellArg} keys and values that are interpreted by the implementation of
	 *                this function to actually cause effects in a game
	 * @param source  The entity from which this effect is happening (typically a card or a minion if it's a battlecry).
	 * @param target  The particular target of this invocation of the spell. When a spell hits multiple targets, like an
	 *                AoE damage effect, this method is called once for each target in the list of targets.
	 * @see SummonSpell#onCast(GameContext, Player, SpellDesc, Entity, Entity) for an example of a complex spell
	 * 		implementation.
	 */
	protected abstract void onCast(GameContext context, Player player, SpellDesc desc, Entity source, Entity target);

	@Override
	public String toString() {
		return "[SPELL " + getClass().getSimpleName() + "]";
	}

	/**
	 * Allows an implementation to log when it encounters unexpected arguments.
	 *
	 * @param logger    The logger to print to
	 * @param context   The context whose {@link GameContext#getGameId()} will be used to mark the log
	 * @param source    The source of this call
	 * @param desc      The description used in this call
	 * @param validArgs The valid arguments
	 */
	protected void checkArguments(Logger logger, GameContext context, Entity source, SpellDesc desc, SpellArg... validArgs) {
		Set<SpellArg> unexpectedArgs = new HashSet<>(desc == null ? Collections.emptySet() : desc.keySet());
		unexpectedArgs.removeAll(Arrays.asList(validArgs == null ? new SpellArg[0] : validArgs));
		unexpectedArgs.removeAll(COMMON_ARGS);
		if (unexpectedArgs.size() > 0) {
			logger.warn("checkArguments {} {}: Unexpected arguments {}", context.getGameId(), source, unexpectedArgs);
		}
	}

	@Override
	public void setDesc(Desc<?, ?> desc) {
		this.desc = (SpellDesc) desc;
	}

	@Override
	public SpellDesc getDesc() {
		return desc;
	}

	/**
	 * Indicates this instance uses Java field memory to maintain state instead of {@code GameContext} memory like the
	 * environment or entities.
	 *
	 * @return
	 */
	protected boolean isNativeStateful() {
		return false;
	}
}

