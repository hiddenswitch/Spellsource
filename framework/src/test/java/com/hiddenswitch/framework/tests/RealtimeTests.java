package com.hiddenswitch.framework.tests;

import com.hiddenswitch.framework.Environment;
import com.hiddenswitch.framework.impl.RealtimeClient;
import io.vertx.core.*;
import io.vertx.junit5.VertxTestContext;
import io.vertx.pgclient.PgPool;
import io.vertx.sqlclient.Row;
import io.vertx.sqlclient.RowSet;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.util.concurrent.atomic.AtomicInteger;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class RealtimeTests extends FrameworkTestBase {

	protected static PgPool pool;

	@BeforeAll
	public static void realtimeSetup(Vertx vertx, VertxTestContext testContext) {
		Handler<AsyncResult<RowSet<Row>>> completing = testContext.completing();
		vertx.runOnContext(v -> {
			pool = Environment.sqlPoolAkaDaoDelegate();
			pool.query("CREATE SCHEMA test;\n" +
					"\n" +
					"CREATE TYPE test.continents AS ENUM (\n" +
					"    'Africa',\n" +
					"    'Antarctica',\n" +
					"    'Asia',\n" +
					"    'Europe',\n" +
					"    'Oceania',\n" +
					"    'North America',\n" +
					"    'South America'\n" +
					");\n" +
					"\n" +
					"-- Countries\n" +
					"CREATE TABLE test.countries (\n" +
					"    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n" +
					"    name character varying(255),\n" +
					"    iso2 character varying(255) NOT NULL,\n" +
					"    iso3 character varying(255),\n" +
					"    local_name text,\n" +
					"    continent test.continents\n" +
					");\n" +
					"COMMENT ON COLUMN test.countries.id IS 'ISO 3166-1 numeric. See https://en.wikipedia.org/wiki/ISO_3166-1_numeric';\n" +
					"COMMENT ON COLUMN test.countries.iso2 IS 'ISO 3166-1 alpha-2. See https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2';\n" +
					"COMMENT ON COLUMN test.countries.iso3 IS 'ISO 3166-1 alpha-3. See https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3';\n" +
					"\n" +
					"-- Cities\n" +
					"CREATE TABLE test.cities (\n" +
					"    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\n" +
					"    name text NOT NULL,\n" +
					"    country_id bigint REFERENCES test.countries,\n" +
					"    district text NOT NULL\n" +
					");")
					.execute(completing);
		});
	}

	@Test
	public void testRealtimeShouldFailToConnect(Vertx vertx, VertxTestContext testContext) {
		(new RealtimeClient(realtime.getRealtimeUrl() + "/invalid").connect())
				.onComplete(testContext.failing(ignored -> testContext.completeNow()));
	}

	@Test
	public void testRealtimeJs(Vertx vertx, VertxTestContext testContext) {
		var insertReceived = Promise.<RealtimeClient.RealtimeChanges>promise();
		var insertReceivedTwice = new AtomicInteger();
		(new RealtimeClient(realtime.getRealtimeUrl())).connect()
				.compose(socket -> {
					var channel = socket.channel("realtime:test:countries");

					var joinedChannel = channel.joined();

					channel.on(RealtimeClient.Channel.INSERT, (handledPayload, ref) -> {
						if (insertReceivedTwice.incrementAndGet() == 2) {
							testContext.failNow(new AssertionError("received another insert after closing"));
						}
						insertReceived.complete(handledPayload.mapTo(RealtimeClient.RealtimeChanges.class));
					});

					// Result is ignored
					return joinedChannel
							.compose(ignored -> {
								var inserted = Promise.<RowSet<Row>>promise();
								pool.query("INSERT INTO test.countries (id, \"name\", iso2, iso3, local_name, continent)\n" +
										"VALUES" +
										" " +
										"(535, 'Bonaire, Sint Eustatius and Saba', 'BQ', 'BES', NULL, NULL);")
										.execute(inserted);
								return inserted.future();
							})
							.compose(ignored -> insertReceived.future())
							.compose(updateRecord -> {
								testContext.verify(() -> {
									assertEquals("countries", updateRecord.getTable(), "should have gotten countries insert");
									assertEquals("Bonaire, Sint Eustatius and Saba", updateRecord.getRecord().get("name"), "should have gotten countries name");
									assertEquals(updateRecord.getType(), RealtimeClient.PayloadType.INSERT, "type should be insert");
								});
								return Future.succeededFuture(socket);
							});
				})
				.compose(socket -> {
					try {
						socket.close();
						return Future.succeededFuture(socket);
					} catch (Throwable t) {
						return Future.failedFuture(t);
					}
				})
				.compose(socket -> {
					var inserted = Promise.<RowSet<Row>>promise();
					pool.query("INSERT INTO test.countries (id, \"name\", iso2, iso3, local_name, continent)\n" +
							"VALUES" +
							" " +
							"(589, 'Another Name', 'AN', 'ANN', NULL, NULL);")
							.execute(inserted);
					return inserted.future();
				})
				.compose(ignored -> {
					var promise = Promise.<Long>promise();
					vertx.setTimer(2000, promise::complete);
					return promise.future();
				})
				.onComplete(testContext.completing());
	}


	/*
	@Test
	public void testPublishSubscribe(Vertx vertx, VertxTestContext testContext) {
		var users = new UserEntityDao(Environment.jooq(), Environment.pool());
		Accounts.createUser("test@test.com", "username", "password")
				.compose(user -> Realtime.publish(
						"user",
						session -> users.findOneById(session.userId())
								.map(entity -> {
									var record = new UserEntityRecord();
									record.from(entity);
									return record;
								})
								.map(Collections::singletonList),
						USER_ENTITY,
						USER_ENTITY.ID,
						Realtime.Session::userId))
				.compose(publication -> Realtime.subscribe(Realtime.Session.forUserId("a"), "user", UserEntityRecord.class, String.class))
				.onComplete(testContext.completing());
	}*/
}
